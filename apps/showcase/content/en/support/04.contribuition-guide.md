---
title: Contribution guide
description: Sollte eigtl zusammen mit allem in Guidelines zu lesen seinâ€¦
---

# Contribution guide

Sollte eigtl zusammen mit allem in Guidelines zu lesen seinâ€¦

---

## outline: [2, 3]

# Contribution Guide

When contributing to onyx, please respect the [Schwarz IT Code of Conduct](https://github.com/SchwarzIT/.github/blob/main/CODE_OF_CONDUCT.md) and our [technical guidelines](/principles/technical-guidelines).

\::: info Target audience
This document is directed at people that are developing **for** onyx.
It gives tips and guidelines on what should or must be considered when working with onyx.
\:::

## Prerequisites / Setup

1. Install \[Node.js]\(<<<https://nodejs.org/en&#x29&#x3E&#x3E&#x3E;;;; version **{{ nodeVersion }}**. :br
   We recommend using [fnm](https://github.com/Schniz/fnm) for managing your node versions which will automatically use the correct node version when working in the onyx repo.

\::: tip Tip: Let _fnm_ automatically choose the right version

- Run `corepack enable` once
- Add `eval $(fnm env --use-on-cd --version-file-strategy=recursive --corepack-enabled --resolve-engines)` to your _shell startup file_ (e.g. `~/.bash_profile`, `~/.zshrc` )

\:::

2. Install the [pnpm](https://pnpm.io/) package manager with a compatible version to `^{{ packageManager.replace("pnpm@", "") }}`

### Recommended IDE Setup

We follow the official Vue recommendation for IDE setup which is [VSCode](https://code.visualstudio.com) with the [Vue - Official](https://marketplace.visualstudio.com/items?itemName=Vue.volar) extension.

## Global scripts

Depending on which package you want to contribute, there are different scripts available. A full list can be found in the `package.json` file of the corresponding package.
Here is a list of the most commonly used global scripts that you can run in the monorepo root folder.

```sh
pnpm install # install all dependencies
pnpm lint:fix:all # lint and fix all packages with eslint
pnpm format:all # format all files with prettier
pnpm dev <package-name> # run dev mode for the given `<package-name>`, e.g. "pnpm dev sit-onyx"
```

## Create new component

To create and contribute a new component to onyx, follow the steps as described below.

### Step 1: Get the code

First, you need to get access to the code. Onyx is Open Source and available on [GitHub](https://github.com/SchwarzIT/onyx).

Just [create a fork](https://github.com/SchwarzIT/onyx/fork) of the repository to get started.

\::: info Access for employees of the Schwarz group
If you are an employee at the [Schwarz group](https://gruppe.schwarz) you can also get direct access to the onyx GitHub repository so you can create branches in there without needing to fork it.

Just contact one of the [team members / engineers](/about/team).
\:::

### Step 2: Install dependencies

If you haven't already, install the dependencies of the monorepo by running:

```sh
pnpm install
```

### Step 3: Run Storybook locally

We are using [Storybook](https://storybook.js.org/) to develop and document onyx components. The Storybook is also deployed on [storybook.onyx.schwarz](https://storybook.onyx.schwarz).

To start it locally for development, just run the following command in the monorepo root folder. Afterwards, you can access Storybook on [localhost:6006](http://localhost:6006)

```sh
pnpm dev sit-onyx
```

### Step 4: Create .vue file

Now, create a new Vue file for your component. All onyx components are located in the `packages/sit-onyx/src/components` folder. Create a new folder with the name of your component and place a `.vue` file with your component name in it.

For the rest of this guide, we assume that we want to create a component named `OnyxExampleComponent`. So you should place it inside `packages/sit-onyx/src/component/OnyxExampleComponent/OnyxExampleComponent.vue`.

You can/should use the following boilerplate code to start your component:

\::: code-group

```vue [OnyxExampleComponent.vue]
<script lang="ts" setup>
import type { OnyxExampleComponentProps } from "./types";
import { useDensity } from "../../composables/density";

const props = defineProps<OnyxExampleComponentProps>();

const { densityClass } = useDensity(props);
</script>

<template>
  <div :class="['onyx-component', 'onyx-example-component', densityClass]">
    Place your component HTML here...
  </div>
</template>

<style lang="scss">
@use "../../styles/mixins/layers.scss";

.onyx-example-component {
  @include layers.component() {
    // component styles here...
    font-family: var(--onyx-font-family);
  }
}
</style>
```

\:::

A few notes on the code snippet above:

1. Every onyx component must have the `onyx-component` CSS class set on its root. This is used/needed for normalizing CSS styles, such as remove default margins from HTML elements etc.
2. The `densityClass` must also be bind to the component root. To learn more about onyx densities, please refer to our [density basics](/basics/density).
3. We use [CSS layers](/principles/contributing/styling.html#css-layers) to allow users to easily override all styles. You must place all your component styles inside `@include layers.component() { // your styles... }`
4. All component styles are global, so you **must** use [BEM](https://getbem.com/naming/) for naming your classes. All nested classes must start with the prefix of your component to avoid global side effects, e.g. `.onyx-example-component__label`.

### Step 5: Create types for properties

To define your component props, create a new `types.ts` file in the component folder and type the properties as needed for your component.
**Note**: The type name must start with your component name (see code snippet below) and extend the `DensityProp` so the [density](/basics/density) can be set for the component.

\::: code-group

```ts [types.ts]
import type { DensityProp } from "../../composables/density";

export type OnyxExampleComponentProps = DensityProp & {
  // your component props, e.g.:
  // label: string;
};
```

\:::

### Step 6: Create stories file

To develop, preview and document the component, you need to create a stories file so the component appear in the Storybook UI.

\::: tip Story title
Please make sure to adjust the Story title to use the category that your component fits in. We use "Basic" here but you can see a list of existing categories on [storybook.onyx.schwarz](https://storybook.onyx.schwarz).

Also make sure to remove the "Onyx" prefix for the title.
\:::

\::: code-group

```ts [OnyxExampleComponent.stories.ts] {5}
import type { Meta, StoryObj } from "@storybook/vue3-vite";
import OnyxExampleComponent from "./OnyxExampleComponent.vue";

const meta: Meta<typeof OnyxExampleComponent> = {
  title: "Basic/ExampleComponent",
  component: OnyxExampleComponent,
};

export default meta;
type Story = StoryObj<typeof OnyxExampleComponent>;

export const Default = {
  args: {
    // you can define component props and slots here to create your component examples, e.g.:
    // label: "Hello World",
  },
} satisfies Story;
```

\:::

### Step 7: Export component

Last but not least, export the component and its types from the library so other users can actually use/import it once the component is released.
Please place the import alphabetically sorted by the component name.

\::: code-group

```ts [packages/sit-onyx/src/index.ts]
export { default as OnyxExampleComponent } from "./components/OnyxExampleComponent/OnyxExampleComponent.vue";
export * from "./components/OnyxExampleComponent/types";
```

\:::

### Step 8: Create pull request

Once you are done with your changes, [create a pull request](https://github.com/SchwarzIT/onyx/compare) and describe the changes that you did.
Please consider our [technical guidelines](/principles/technical-guidelines) when contributing to onyx.

If you are contributing multiple components, features or your contributing is big, please split up the contribution and create multiple PRs!

\::: tip Draft PRs
Don't worry if your PR is not completely done yet because you have open questions etc.
You can also create a draft pull request so the onyx team can help you out or finalize the PR for you.
\:::

When your PR gets approved, you can expect a pre-release immediately after it is merged. Production releases are planned to be published every 2 weeks after the release of version 1.0.0.

\::: tip Screenshot tests
Component screenshot tests using Playwright will only be performed in our [GitHub workflows](https://github.com/SchwarzIT/onyx/actions) to ensure consistency of the resulting images which vary on different operating systems.

If you made visual changes to components, you can use [this Workflow](https://github.com/SchwarzIT/onyx/actions/workflows/playwright-screenshots.yml) to update the screenshots on your branch.
\:::

### Step 9: Create changeset

If your changes affect the user and need to be released (e.g. added a new component or feature), you need to [add a changeset](https://github.com/SchwarzIT/onyx/blob/main/.changeset/README.md).

With this, the [onyx changelog and versioning](/development/packages/changelogs/sit-onyx.html) is managed automatically.

In the monorepo root, run:

```sh
npx changeset add
```

and follow the interactive CLI there. Please describe your changes in perspective of the user since this will end up in the changelog.

## Further reading

Here you can find more details about:

- ðŸ“š [Writing stories](./stories)
- ðŸŽ¨ [Creating styles](./styling)
- ðŸŽ­ [Implementing tests](./testing)

---

# Storybook

For development and API documentation we make use of [Storybook](https://storybook.js.org/).

A **Story** is a specific scenario or state of a component that showcases its functionality, appearance, or behavior. It helps developers and designers visualize and test different variations of a component in isolation.

All stories for a single component are kept in a neighboring `<component>.stories.ts` file.

\::: info
The next sections describe the content of a `*.stories.ts` file in more detail.
Feel free to [skip to the end](#tl-dr) to see the complete example and a _TL;DR_.
\:::

## Meta section

First off we have the [`Meta`](https://storybook.js.org/docs/writing-stories/typescript#typing-stories-with-meta-and-storyobj) object.
Here the component is described and documented.
Using tsdoc, a general description is added above the `meta` constant.

- The `title` attribute defines where in the storybook the component is placed and what its title is. Categories and the title are separated by slashes ("`/`").
- `component` sets the Component that will be used for all Stories in this file. The documentation for all properties will be extracted from its types and their [tsdoc](https://tsdoc.org/) block.
- With the [`argTypes`](https://storybook.js.org/docs/api/arg-types#manually-specifying-argtypes) attribute the components property documentation can be extended and overwritten.
  Usually this is not necessary as Storybook infers the properties, their types and description from the component types.
  However as shown in the example below, it can be useful to overwrite Storybooks input element using the `control` property.
- To highlight useful native DOM events, the `withNativeEventLogging` utility can be used. It enables logging and documentation for the defined DOM events.

Make sure to export `meta` as default so Storybook can find the Story.

<<< ./stories-example.ts#meta

## Actual Stories

Every non-default export represents a `Story`, where the export name is also the name of the story.
The first story is usually called `Default`.

- The description of the story object is done via [tsdoc](https://tsdoc.org/).
- We use `StoryObj<typeof OnyxComponent>` to enable typed code completion.
- A story must define `args` which represents the props that are passed to component.

To add further stories, add more named exports.
Consider reusing the `Default` stories args.

<<< ./stories-example.ts#story

## Slots

Storybook treats Slots like props, therefore they are also configured via the `args`.
A slot and its content are defined using [Render Functions](https://vuejs.org/guide/extras/render-function.html).
A Render Functions must return a [VNode](https://vuejs.org/api/render-function.html#h) or an array of VNodes.

<<< ./stories-example.ts#slot

## TL;DR

\::: tip TL;DR

- Descriptions and types are extracted by Storybook from the components types and [tsdoc](https://tsdoc.org/)
- Meta details are configured via a default export with type `Meta<typeof OnyxComponent>`
- Stories are defined as Named Exports with type `StoryObj<typeof OnyxComponent>`
- Props and slot content for a Story are passed with the `args` property
- Slots are defined using [Render Functions](https://vuejs.org/guide/extras/render-function.html)
  \:::

Complete example:

<<< ./stories-example.ts

---

# Styling

We use [SCSS](https://sass-lang.com/documentation/syntax/#scss) as CSS preprocessor.
Any valid CSS is also valid SCSS, that should make it easy to get started.

All our design variables are provided as [CSS custom properties](https://developer.mozilla.org/en-US/docs/Web/CSS/Using_CSS_custom_properties).
An overview can be found [here](/variables/introduction.html).

For a general overview of our (S)CSS guidelines refer to our [CSS Principles](/principles/technical-guidelines.html#css).

## CSS Layers

We make use of [Cascade Layers](https://developer.mozilla.org/en-US/docs/Learn/CSS/Building_blocks/Cascade_layers) to simplify how different style sources are combined.
By putting all our styles into layers they can also be easily overwritten by users.

Therefore, the `@include layers.component()` mixin must be used.
It will put the contained rules into the `onyx.component` layer and normalize stylings.

<<< ./styling-example.vue#screenshot-testing {scss}

## Custom density styles

For most cases, the [CSS variables for densities](/variables/spacings) will already support that the component adjusts its spacings based on the current density.
In exceptional cases it might be necessary to apply special style rules for the densities, for which the default spacings do not work.

You can use our density mixins in this case:

<<< ./styling-example.vue#densities {scss}

---

# Testing

We require every component to be thoroughly tested.
**onyx** uses [Playwright](https://playwright.dev/) and [Vitest](https://vitest.dev/) for testing.

## Component tests

Generally [playwright component tests](https://playwright.dev/docs/test-components) (kept in `.ct.tsx`-files) suffice to test a component.

Component tests must include screenshot tests to ensure that any style changes happen intentionally and can be approved by our UX.
To easily generate and test screenshots for all main states the `executeMatrixScreenshotTest` utility is to be used.

<<< ./testing-example.ct.tsx#executeMatrixScreenshotTest

The utility creates a screenshot for every combination of `rows` and `columns`.
These are then combined in into grid and saves a single screenshot of it.
Here is an example for the OnyxButton:

![Example of a screenshot matrix for the OnyxButton](./example-matrix.png)

\::: warning
Choose the columns and rows carefully, as the number of combination grows quadratically. It might be preferable to create a new screenshot matrix instead of adding more columns/rows.
\:::

Accessibility tests (using [axe-core](https://github.com/dequelabs/axe-core)) are also run for every combination.

For standalone tests or more complicated setups, [`toHaveScreenshot`](https://playwright.dev/docs/test-snapshots) can be used directly:

<<< ./testing-example.ct.tsx#toHaveScreenshot

### Development

In our monorepo component tests are run non-interactively using the `pnpm test:playwright` script.

To use Playwright interactively run `pnpm exec playwright test --ui` (add the `--headed` flag to open the see the- browsers) in the package directory.

### CI

To investigate failing playwright tests from the CI locally:
You can run `pnpm gh:show-report` in the root, which will

1. Download the \`html-report--attempt-x\` artifact **_after_** the pipeline has finished.
2. Unzip the archive
3. `cd` into the package you want to see the report for
4. Run `pnpm dlx playwright show-report`

### VSCode

We highly recommend to use the [Playwright Test for VSCode](https://marketplace.visualstudio.com/items?itemName=ms-playwright.playwright) extension for running component tests in development.
It allows to build and run specific tests interactively, directly from the IDE (see annotation `3` in screenshot beneath).
If you encounter any issues please make sure

- to run the `pnpm build` script at least once for the package
- to only select the playwright config file for the current package your are testing
- to run `Run global teardown`, `Close All Browsers` and `Clear Cache`

You find the playwright VSCode extension settings (see annotation `2` in screenshot beneath) in the `Testing` section of VSCode (annotation `1`).

![Playwright for VSCode overview](./playwright-test-for-vs-code.png)

## Unit tests

For self-contained logic, excluding Vue components, unit tests (kept in `.spec.ts`-files) can be written using [Vitest](https://vitest.dev/).

In our monorepo unit tests are run using the `pnpm test` script.

---

# Patterns

This page explains which common patterns we follow when developing onyx and how to use them.
These patterns are implemented through [**composables**](https://vuejs.org/guide/reusability/composables.html) and enforced through [**linting rules**](https://eslint.org/docs/latest/extend/custom-rules), where possible.

## Root Attribute Forwarding

For implementing necessary layout, styling and ARIA requirements, it is often necessary to wrap interactive HTML elements.
To enable the developers to be able to set custom attributes and event-listeners on these, we forward most attributes to the relevant (e.g. input or button) element.
The only attributes that are not forwarded are `style` and `class` with the assumption being, that these are only useful and intended to be set on the root element of the component.

<<< ../../../../../packages/sit-onyx/src/utils/attrs.ts#docs

## (Shared) Child Props Forwarding

When a parent component is a wrapper for another (support) component, the parent usually extends all or a subset of the child's properties.
The relevant child props need then to be forwarded to the child component.
This can easily be achieved by using [`v-bind`](https://vuejs.org/api/built-in-directives.html#v-bind), e.g.

```vue [ParentComponent.vue]
<script setup lang="ts">
const props = defineProps<ParentProps & ChildProps>();
</script>
<template>
  <!-- âš ï¸ Don't do this -->
  <ChildComponent v-bind="props" />
</template>
```

Unfortunately this has the unwanted side-effect of all extraneous props being applied as attributes.
So when the parent defines props which do not exist on the child component, they are treated as _[fallthrough attributes](https://vuejs.org/guide/components/attrs.html#fallthrough-attributes)_.
Besides cluttering the HTML with irrelevant attributes this also can have disruptive side-effects when the prop name accidentally matches a valid html attribute (e.g. [inert](https://developer.mozilla.org/en-US/docs/Web/HTML/Reference/Global_attributes/inert) or [hidden](https://developer.mozilla.org/en-US/docs/Web/HTML/Reference/Global_attributes/hidden)).

Which might look like this in the DOM tree:

```html
<div class="child-component" parent-prop-1="parent-prop-value-1" parent-prop-2="[object Object]">
  <!-- ... -->
</div>
```

To avoid this, our `useForwardProps` composable can be used:

<<< ../../../../../packages/sit-onyx/src/utils/props.ts#docs

## State Control

We want to give the user maximum control of component state, which is achieved by providing props with _two-way binding_ support via Vue's [`v-model`](https://vuejs.org/guide/components/v-model.html#basic-usage).
To not require the developer to declare `ref`s for state they do not care about, the state will be stored internally if left undefined by the user.

Unfortunately the Vue native [`defineModel`](https://vuejs.org/api/sfc-script-setup.html#definemodel) compiler macro behaves not as expected, as it will prefer internal state updates over external, unchanged state (e.g. `<Comp :open="true" />` will not be considered anymore after an `update:open` with value `false`).

Therefore we created a custom composable `useVModel`, which will prefer the external state:

<<< ../../../../../packages/sit-onyx/src/composables/useVModel.ts#docs

---
