---
title: Breakpoints, Grid & Media Queries
description: ....
---

# Breakpoints, Grid & Media Queries

EINLEITUNGSATZ

## Description

Our design system utilizes column grids to establish structured layouts that organize content, components, and UI elements into a cohesive hierarchy. This framework ensures consistent alignment and distribution across all applications. By acting as the foundation for responsive behavior, the grid enables seamless adaptation across various screen sizes and resolutions, ultimately enhancing usability and the overall user experience.

Explore the Grid: To see these principles in action, visit our Grid Playground.

## Understanding the Grid

The grid architecture consists of three interdependent components: margins, columns, and gutters.

| Component | Definition & Purpose                                                                                             | Behavior                                                                       |
| :-------- | :--------------------------------------------------------------------------------------------------------------- | :----------------------------------------------------------------------------- |
| Margins   | The outer boundaries of the grid that provide breathing room between the content and the edges of the interface. | Values are constant but adapt specifically to each screen breakpoint.          |
| Columns   | The vertical building blocks where content, components, and UI elements are placed.                              | Widths resize proportionally to fill the available horizontal space.           |
| Gutters   | The intentional spacing between columns that ensures content remains separated and organized.                    | Widths remain constant to maintain consistent internal spacing per breakpoint. |

## Responsive Column Logic

A key feature of our grid is the adaptive column count. To maintain a functional layout across devices, we adjust the number of columns based on screen real estate:

Small Screens (Mobile): Utilize fewer columns to maintain a readable, condensed layout.

Large Screens (Desktop): Increase the column count to leverage the expanded canvas and display more content simultaneously.

## Ultra-Wide Screens & Readability

On ultra-wide displays (2K and above), an unrestricted grid can lead to excessively long line lengths that hinder readability. We recommend applying a maximum content width—typically 1440px or 1920px—to strike a balance between screen usage and optimal content presentation. While these boundaries are optional, they are highly encouraged to guarantee a premium user experience.

## Breakpoints

We recognize that business applications must function flawlessly on everything from compact mobile devices to expansive monitors. Our breakpoints define the specific transition points where the UI responds and the grid configuration changes.

- Alignment: By default, all grids are left-aligned.
- Customization: While the grid can be center-aligned for specific use cases, we advise using this setting carefully. Alignment should depend on the specific application type and content density. If in doubt, stick to the default left-alignment or consult our core design team.

## Sidebar Grid

The sidebar operates on its own internal grid logic. Similar to the main viewport, it incorporates margins, columns, and gutters that adapt dynamically to the sidebar's current width. However, the specific values for these units differ from the global screen grid to accommodate the sidebar's narrower constraints.

## Screen Resolutions & Scaling

### Pixel Density

Pixel density (PPI) determines the level of detail on a display. On modern high-resolution smartphones, pixels are so concentrated they are indistinguishable to the eye. Because a high-resolution 5-inch screen can have a similar pixel count to a 27-inch monitor, we automatically scale content to ensure that text and elements remain at a comfortable, readable size regardless of physical pixel count.

### Scaling Factor

Mobile devices use a logical unit (independent of physical pixels) to maintain visual consistency. High-resolution displays use multiple physical pixels to render a single logical pixel. The scaling factor is determined by the device's pixel density, ensuring a uniform user experience across iOS, Android, and web platforms.

## Technical Implementation

### SCSS Mixins

To apply styles based on our design system's breakpoints, we provide a dedicated SCSS mixin. This ensures your custom CSS stays synchronized with the core grid specifications.

```SCSS
// Example usage of the breakpoint mixin
@include onyx-breakpoint(md) {
.your-element {
// Styles for medium screens and up
}
}
```

### Container Queries

In addition to standard media queries, we support Container Queries. These allow a component to respond to the width of its parent container rather than the entire viewport—perfect for complex, modular layouts.

Note: Ensure you set the container-type CSS property on the parent element, or the container query will not trigger.

### Usage in JavaScript

If you need to access breakpoint values within JavaScript (e.g., for use with a ResizeObserver), you can import them directly from our styles package:

```JavaScript
import { breakpoints } from 'sit-onyx/breakpoints';
```

---

Column grids in ui design and development establish a structured layout, organizing content, components and elements cohesively. They provide a framework for alignment and distribution, ensuring consistency and hierarchy. Additionally, grids serve as the foundation for smooth responsive behavior, allowing seamless adoption to different screen sizes and resolutions, ultimately enhancing usability and overall user experience.

To see the grid and breakpoints in action, feel free to have a look on the [grid playground](https://storybook.onyx.schwarz/?path=/story/examples-gridplayground--default).

---

## Understanding the grid

To understand the anatomy of a column grid, it is essential to comprehend its key components: margins, columns and gutters, which function harmoniously together. Visual examples and further details can be found below.

![Description of how the grid key components are layed out. Multiple vertical tracks are stretching over the whole page: the outermost tracks are "margins". Inbetween is an odd amount of columns, where every even column is a "gutter" and every odd track is a "column"](/assets/grid-explanation.png)

### 1 Margins

Margins delineate the outer boundaries of the grid, providing spacing between the content and the edges of the interface. The margin has always a fixed value, that adopts to the breakpoint of the screen.

### 2 Columns

Columns define the vertical divisions within the grid, organizing content into distinct sections. The value of the column unit is always flexible, what guarantees fluent sizing behavior of the content elements.

### 3 Gutter

Gutters are the space between columns, ensuring adequate separation and consistent spacing between objects. The width of the gutter has always a fix value, that is defined by the breakpoint.

## Columns

One of the key characteristics of columns is their flexibility in width, allowing them to adapt dynamically to the size of the screen. However, on smaller screens a condensed layout is achieved by utilizing fewer columns, where on the other side wider screens like desktop monitors increase the number of columns to make the most of the available space.
This adaptive approach ensures a continuously and consistent width of elements across different screen sizes. Moreover, as the number of columns increases on larger screens, additional virtual space is effectively gained. This expanded canvas provides designers and developers with more room to showcase content.

To maintain user's happiness with ultra-wide screens, such as 2k and above, consider a maximum width restriction on the grid, which obviously effects the content, as well.
warning Attention
These limits can be set to **1440px** or **1920px**, striking a balance between expansive screen usage and optimal content presentation.

While these grid boundaries are optional, it is highly recommended to do so to guarantee readability.

The determination of the optimal number of columns is closely tied to the concept of the breakpoints, which define the points at which the layout of the ui responds to changes in screen size. The onyx [design and dev team](/about/team) responsible for the fundamental guidelines established those breakpoints and grid implementations.

## Breakpoints

With the onyx design approach, we recognize the significance of tailoring the layout to different screen sizes through the implementation of specific breakpoints. Each breakpoint corresponds to a distinct grid system, carefully crafted to accommodate the diverse needs of onyx applications. From small mobile screens to expansive desktop displays, onyx offers a range of specifications and adjustments for the column grid, ensuring seamless adaption across various devices and screen resolution.

For the technical implementation, please see the [developer documentation](/development/breakpoints).

![All breakpoints layed out on top of each-other with their units included. The details can be found in the following section.](/assets/breakpoints.png)

### 2xs breakpoint

The smallest breakpoint starts at 320px and ends at 576px screen size. It is mostly used with smartphone screens.

| Unit            | Value |
| --------------- | ----: |
| Margin          |  16px |
| Column quantity |     4 |
| Column width    |  flex |
| Gutter          |  16px |

### xs breakpoint

This breakpoint starts at 577px and ends at 768px screen size. It is mostly used with portrait framed tablet screens.

| Unit            | Value |
| --------------- | ----: |
| Margin          |  16px |
| Column quantity |     8 |
| Column width    |  flex |
| Gutter          |  16px |

### sm breakpoint

This breakpoint starts at 769px and ends at 992px screen size. It is mostly used with landscape framed tablet screens.

| Unit            | Value |
| --------------- | ----: |
| Margin          |  32px |
| Column quantity |     8 |
| Column width    |  flex |
| Gutter          |  24px |

### md breakpoint

This breakpoint starts at 993px and ends at 1440px screen size. It is mostly used with smaller desktop screens.

| Unit            | Value |
| --------------- | ----: |
| Margin          |  64px |
| Column quantity |    12 |
| Column width    |  flex |
| Gutter          |  24px |

### lg breakpoint

This breakpoint starts at 1441 and ends at 1920px screen size. It is mostly used with larger desktop screens.

| Unit            |    Value |
| --------------- | -------: |
| Margin          |     64px |
| Column quantity | 12 or 16 |
| Column width    |     flex |
| Gutter          |     32px |

Maximum content width can manually be set to the **md** breakpoint width.

Details can be found [here](#columns).

### xl breakpoint

This breakpoint starts at 1921px and has no maximum limit. It is mostly used with very large desktop screens.

| Unit            |        Value |
| --------------- | -----------: |
| Margin          |         64px |
| Column quantity | 12, 16 or 20 |
| Column width    |         flex |
| Gutter          |         32px |

Maximum content width can manually be set to the **md** and **lg** breakpoint width.

Details can be found [here](#columns).

warning Attention
By default, all grids are `left aligned` to the edge of the screen. For having more flexibility, the grid can be `center aligned`, as well. Keep in mind that this is not the default setting. Please use the individual alignment carefully, because it highly depends on the type of the application and the content it has to display. If you are not sure, stick with the default setting or talk to the ux designer, that is assigned to your project.

## Sidebar grid

Overall, the grid and breakpoints for the sidebar operate the same way like those employed for the whole screen, in terms of logic. Similar to the whole-screen-grid- the sidebar incorporates margins, columns, and gutters, that dynamically adapt to its width. However, the values used for the sidebar grid and breakpoints are varying. For detailed specifications, refer to the definitions provided below.

![All sidebar breakpoints layed out on top of each-other with their units included. The details can also be found in the following section.](/assets/sidebar-breakpoints.png)

### sm breakpoint

This is the default side of the sidebar.

| Unit            | Value |
| --------------- | ----: |
| Margin          |  16px |
| Column quantity |     2 |
| Column width    |  flex |
| Gutter          |  16px |

### md breakpoint

| Unit            | Value |
| --------------- | ----: |
| Margin          |  16px |
| Column quantity |     4 |
| Column width    |  flex |
| Gutter          |  16px |

### lg breakpoint

| Unit            | Value |
| --------------- | ----: |
| Margin          |  32px |
| Column quantity |     8 |
| Column width    |  flex |
| Gutter          |  24px |

### xl breakpoint

| Unit            | Value |
| --------------- | ----: |
| Margin          |  64px |
| Column quantity |    12 |
| Column width    |  flex |
| Gutter          |  24px |

## Screen resolutions

### Pixel density

Pixel density refers to the concentration of pixels within an inch, dictating the level of detail and clarity in digital displays. Higher pixel density results in sharper images and text. For instance, an image sized at 100x100 pixels appears larger on devices with lower pixel density compared to those with higher density. Modern smartphone displays boast exceptionally high resolutions, rendering individual pixels virtually indistinguishable to the naked eye. In fact, the pixel count on a 5-inch smartphone screen can rival that of a standard 27-inch monitor. However, directly adopting dimensions and font sizes from traditional PC monitors would render elements and text too small for comfortable viewing. To address this, content is automatically scaled on high-resolution screens to ensure optimal readability and usability.

![Comparison of a screen with high pixel density and a screen with low pixel density](/assets/screen-density.png)

### Scaling factor

Modern mobile devices employ scaling techniques to maintain consistency in displaying UI elements across various screen resolutions. High-resolution displays often use multiple physical pixels to represent a single illustrated pixel. To ensure uniformity, a logical unit is established, independent of the device's actual pixels, and appears consistent on all displays through scaling. While the specific definition of these logical units varies between iOS and Android, the fundamental principle remains consistent. The scaling factor employed is determined by the pixel density of the device, ensuring an optimal user experience across different mobile platforms.

![high scaling factor vs. low scaling factor](/assets/scaling-factor.png)
warning Attention
The scaling factor enables the design of content at a logical resolution, irrespective of the device's actual resolution. In these foundational guidelines here, all dimensions and distances are specified based on this logical resolution rather than the physical resolution of the device. The device itself handles the scaling process to match the available pixels, ensuring consistent display across various devices.

---

# Supported Breakpoints (DEV)

To easily apply CSS depending on the onyx breakpoint, we offer a SCSS mixin you can use.

For further information, please see the [design documentation](/basics/breakpoints-grid#breakpoints).

The following breakpoints are supported:

<<< @/../../../packages/sit-onyx/src/styles/breakpoints.scss#breakpoints

## Usage (Media Queries)

```scss
@use "sit-onyx/breakpoints.scss";

.some-class {
  @include breakpoints.screen(max, sm) {
    // your styles for md screens and smaller
  }

  @include breakpoints.screen(min, md) {
    // your styles for md screens and larger
  }
}
```

## Container queries

There is also an equivalent for using [container queries](https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_containment/Container_queries) instead of [media queries](https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_media_queries/Using_media_queries) so the breakpoint is considered for the element width instead if the whole viewport.

Make sure to set the [`container-type`](https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_containment/Container_queries#using_container_queries) CSS property accordingly, otherwise the container query will not work.

```scss
@use "sit-onyx/breakpoints.scss";

.some-class {
  container-type: size;

  @include breakpoints.container(max, sm) {
    // your styles for md containers and smaller
  }

  @include breakpoints.container(min, md) {
    // your styles for md containers and larger
  }

  // the breakpoint is inclusive so if you e.g. want to use
  // min and max for the same breakpoint you should
  // define an offset for either min or max
  @include breakpoints.container(max, xl) {
    // your styles for smaller and equal xl containers
  }

  @include breakpoints.container(min, xl, $offset: 1) {
    // your styles for greater than xl containers (exclusive)
  }
}
```

## Use in JavaScript

If you need to access the breakpoints via JavaScript (e.g. inside a [`ResizeObserver`](https://developer.mozilla.org/en-US/docs/Web/API/ResizeObserver)), you can import them like so:

```ts
import { ONYX_BREAKPOINTS } from "sit-onyx";

console.log(`Width for sm breakpoint is: ${ONYX_BREAKPOINTS.sm}px`);
```
