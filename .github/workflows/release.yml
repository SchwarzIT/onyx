name: Release
on:
  push:
    branches:
      - "main"
  workflow_dispatch:

concurrency: ${{ github.workflow }}-${{ github.ref }}

env:
  TURBO_TOKEN: ${{ secrets.TURBO_REMOTE_CACHE__TURBO_TOKEN }}

jobs:
  release:
    name: Release
    runs-on: ubuntu-latest
    permissions:
      id-token: write
      contents: write
      packages: write
      pull-requests: write
    outputs:
      # We can use the `published` boolean in other steps to decide, when we do deployments
      published: ${{ steps.Publish.outputs.published }}
      environment_docs: ${{ steps.DetermineDeployTargets.outputs.ENVIRONMENT_DOCS }}
      environment_sit-onyx: ${{ steps.DetermineDeployTargets.outputs.ENVIRONMENT_STORYBOOK }}
      environment_playground: ${{ steps.DetermineDeployTargets.outputs.ENVIRONMENT_PLAYGROUND }}
      environment_demo-app: ${{ steps.DetermineDeployTargets.outputs.ENVIRONMENT_DEMO_APP }}

    steps:
      - uses: actions/checkout@v5
        with:
          ssh-key: ${{ secrets.GH_PUSH_PROTECTED_KEY }}
          # needed when building VitePress docs so timestamps can be calculated correctly
          fetch-depth: 0

      - uses: ./.github/templates/node-setup

      - name: 🛠️ Build packages
        run: pnpm build:all --filter=!@sit-onyx/docs-app --filter=!@sit-onyx/demo-app

      - name: 🤖 Configure Git Bot
        run: |
          git config user.name "Release Bot[bot]"
          git config user.email "bot@example.com"

      # All existing changesets are applied for a snapshot release.
      # In case of a "real" release all changesets will already have been applied through a PR, so this step won't have an effect.
      - name: Determine snapshot versions
        run: pnpm exec changeset version --snapshot dev

      - name: Publish
        id: Publish
        uses: changesets/action@v1
        with:
          publish: "pnpm exec changeset publish"
          createGithubReleases: true
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Determine Deploy Targets
        id: DetermineDeployTargets
        if: steps.Publish.outputs.published == 'true'
        run: |
          # Maps [{"name": "docs", "version": "1.2.0"}, {"name": "demo-app", "version": "0.8.9"}] 
          # to [{ "name": "docs", "deploy": "prod" }, { "name": "demo-app", "deploy": "dev" }]
          export mapped=echo '${{ steps.Publish.outputs.publishedPackages }}' | jq -c 'map_values({ name: .name, deploy: (if .version | test("^\\d+.\\d+.\\d+$") then "prod" else "dev" end) })'

          # Expose the deploy environment ("prod", "dev" or "") for each package as output.
          ENVIRONMENT_DOCS=$(echo $mapped | jq -c '.[] | select(.name == "@sit-onyx/docs-app") | .deploy')
          ENVIRONMENT_STORYBOOK=$(echo $mapped | jq -c '.[] | select(.name == "sit-onyx") | .deploy')
          ENVIRONMENT_PLAYGROUND=$(echo $mapped | jq -c '.[] | select(.name == "@sit-onyx/playground-app") | .deploy')
          ENVIRONMENT_DEMO_APP=$(echo $mapped | jq -c '.[] | select(.name == "@sit-onyx/demo-app") | .deploy')
          echo "ENVIRONMENT_DOCS=$ENVIRONMENT_DOCS" >> "$GITHUB_OUTPUT"
          echo "ENVIRONMENT_STORYBOOK=$ENVIRONMENT_STORYBOOK" >> "$GITHUB_OUTPUT"
          echo "ENVIRONMENT_PLAYGROUND=$ENVIRONMENT_PLAYGROUND" >> "$GITHUB_OUTPUT"
          echo "ENVIRONMENT_DEMO_APP=$ENVIRONMENT_DEMO_APP" >> "$GITHUB_OUTPUT"

  deploy-websites:
    name: deploy-websites
    needs: release
    if: needs.release.outputs.published == 'true'
    uses: ./.github/workflows/deploy-websites.yml
    with:
      environment_docs: ${{ needs.release.outputs.environment_docs }}
      environment_sit-onyx: ${{ needs.release.outputs.environment_sit-onyx }}
      environment_playground: ${{ needs.release.outputs.environment_playground }}
      environment_demo-app: ${{ needs.release.outputs.environment_demo-app }}
